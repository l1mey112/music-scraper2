import { sql } from "drizzle-orm";
import { db } from "./db"
import * as schema from './schema';

type QobuzKeys = {
	app_id: string
	secret: string[]
	valid_secret: string
}

export const qobuz_id = process.env.QOBUZ_ID!
export const qobuz_token = process.env.QOBUZ_TOKEN!

if (!qobuz_id || !qobuz_token) {
	console.error('missing qobuz id or qobuz token')
	process.exit(1)
}

// generated by LLM, ignore the shitty ass code
// gets the job done though
async function get_secrets_and_app_id(): Promise<[string, string[]]> {
	
	const seed_timezone_regex = /[a-z]\.initialSeed\("(?<seed>[\w=]+)",window\.utimezone\.(?<timezone>[a-z]+)\)/g
	const info_extras_regex = (timezones: string) => new RegExp(`name:"\\w+/(?<timezone>${timezones})",info:"(?<info>[\\w=]+)",extras:"(?<extras>[\\w=]+)"`, "g")
	const app_id_regex = /production:{api:{appId:"(?<app_id>\d{9})",appSecret:"(\w{32})/

	const response = await fetch("https://play.qobuz.com/login")
	const login_page = await response.text()

	const bundle_url_match = login_page.match(/<script src="(\/resources\/\d+\.\d+\.\d+-[a-z]\d{3}\/bundle\.js)"><\/script>/)
	if (!bundle_url_match) {
		throw new Error("Could not find bundle URL.")
	}
	const bundle_url = bundle_url_match[1]

	const bundle_response = await fetch("https://play.qobuz.com" + bundle_url)
	const bundle = await bundle_response.text()

	const app_id_match = bundle.match(app_id_regex)
	if (!app_id_match) {
		throw new Error("Could not find app id.")
	}
	const app_id = app_id_match.groups!.app_id

	const seed_matches = bundle.matchAll(seed_timezone_regex)
	const secrets: Record<string, string[]> = {}
	for (const match of seed_matches) {
		const { seed, timezone } = match.groups!
		secrets[timezone] = [seed]
	}

	const keypairs = Object.entries(secrets)
	const [first_key, first_value] = keypairs[1]
	delete secrets[first_key]
	secrets[first_key] = first_value

	const regex = info_extras_regex(Object.keys(secrets).map(tz => tz.charAt(0).toUpperCase() + tz.slice(1)).join("|"))
	const info_extras_matches = bundle.matchAll(regex)
	for (const match of info_extras_matches) {
		const { timezone, info, extras } = match.groups!
		secrets[timezone.toLowerCase()] = [...secrets[timezone.toLowerCase()], info, extras]
	}
	
	const secrets_s: Record<string, string> = {}

	for (const secret_pair in secrets) {
		secrets_s[secret_pair] = atob(secrets[secret_pair].join("").slice(0, -44))
	}

	const secrets_list = Object.values(secrets_s).filter(secret => secret !== "")

	return [app_id, secrets_list]
}


async function get_app_id_and_secrets(): Promise<QobuzKeys> {
	console.log(`qobuz: getting secrets and app id`)

	const [app_id, secrets_list] = await get_secrets_and_app_id()

	console.log(`qobuz: logging in (app_id: ${app_id})`)

	// we're using tokens, so this doesn't really matter
	// though it's a good sanity check

	const urlparams = `?user_id=${qobuz_id}&user_auth_token=${qobuz_token}&app_id=${app_id}`

	// oh qobuz... python and regex held together by duct tape
	// fails: /user/login/?url_params
	// works: /user/login?url_params

	// ensure not to have a leading slash

	const response = await fetch(`https://www.qobuz.com/api.json/0.2/user/login${urlparams}`, {
		method: "GET",
		headers: {
			"X-App-Id": app_id,
			"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0",
		},
	})

	if (!response.ok) {
		console.error(`qobuz: failed to login: ${response.status} ${await response.text()}`)
		process.exit(1)
	}

	const json: any = await response.json()

	if (!json.user.credential.parameters) {
		console.error(`qobuz: free accounts cannot download tracks`)
		process.exit(1)
	}

	console.log(`qobuz: searching for keys (app_id: ${app_id})`)

	// assert json.user_auth_token == qobuz_token
	// apply header: X-User-Auth-Token: qobuz_token

	// find valid secret from the two
	const responses = await Promise.all(secrets_list.map(async secret => {
		// request for file URL copied from the original function

		const unix_seconds = Math.floor(Date.now() / 1000)
		const sig = `trackgetFileUrlformat_id${qobuz_default_quality}intentstreamtrack_id${19512574}${unix_seconds}${secret}`

		// md5 hexdigest
		const hasher = new Bun.CryptoHasher("md5")
		hasher.update(Buffer.from(sig, "utf8"))
		const hash = hasher.digest("hex")

		const params =
			`?request_ts=${unix_seconds}` +
			`&request_sig=${hash}` +
			`&track_id=${19512574}` +
			`&format_id=${qobuz_default_quality}` +
			`&intent=stream`

		const response = await fetch(`https://www.qobuz.com/api.json/0.2/track/getFileUrl${params}`, {
			method: "GET",
			headers: {
				"X-App-Id": app_id,
				"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0",
				"X-User-Auth-Token": qobuz_token,
			},
		})

		if (!response.ok) {
			return undefined
		}

		return response.json()
	}))

	let valid_secret
	let idx = 0
	for (const response of responses) {
		if (response) {
			valid_secret = secrets_list[idx]
		}
		idx++
	}
	
	if (!valid_secret) {
		console.error(`qobuz: could not find a valid secret out of ${secrets_list}`)
		process.exit(1)
	}

	console.log(`qobuz: found valid secret`)

	return { app_id, secret: secrets_list, valid_secret: valid_secret }
}

// a 3 on the streamrip quality scale
// (5, 6, 7, 27)
//        ^
const qobuz_default_quality = 7 // 7 (24 bit, â‰¤ 96 kHz)

export async function qobuz_api(short_url: string): Promise<Response> {
	return fetch(`https://www.qobuz.com/api.json/0.2/${short_url}`, {
		method: "GET",
		headers: {
			"X-App-Id": qobuz_keys.app_id,
			"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0",
			"X-User-Auth-Token": qobuz_token,
		},
	})
}

/* {
	track_id: 252881807,
	duration: 145,
	url: "https://streaming-qobuz-std.akamaized.net/file?uid=2972644&eid=252881807&fmt=6&profile=raw&app_id=950096963&cid=2106822&etsp=1710739861&hmac=jScejVWKNLE2Lk5crKcGvzTShGY",
	format_id: 6,
	mime_type: "audio/flac",
	restrictions: [
		{
		code: "FormatRestrictedByFormatAvailability",
		}
	],
	sampling_rate: 44.1,
	bit_depth: 16,
	blob: "000000252881807",
} */

// TODO: make it return undefined too

// returns status and json
async function qobuz_request_file_url(track_id: number): Promise<any> {
	const unix_seconds = Math.floor(Date.now() / 1000)
	const sig = `trackgetFileUrlformat_id${qobuz_default_quality}intentstreamtrack_id${track_id}${unix_seconds}${qobuz_keys.valid_secret}`

	// md5 hexdigest
	const hasher = new Bun.CryptoHasher("md5")
	hasher.update(Buffer.from(sig, "utf8"))
	const hash = hasher.digest("hex")

	const params =
		`?request_ts=${unix_seconds}` +
		`&request_sig=${hash}` +
		`&track_id=${track_id}` +
		`&format_id=${qobuz_default_quality}` +
		`&intent=stream`

	const response = await qobuz_api(`track/getFileUrl${params}`)

	if (!response.ok) {
		// console.error(`qobuz_request_file_url: failed to get file url (id: ${track_id}): ${response.status} ${await response.text()}`)
		return undefined
	}

	return await response.json()
}

export let qobuz_keys: QobuzKeys

export async function qobuz_create() {
	// find if exists
	const t: { data: QobuzKeys } | undefined = db.select({ data: schema.thirdparty_store.data })
		.from(schema.thirdparty_store)
		.where(sql`kind = 'qobuz_keys'`)
		.limit(1)
		.all()[0] as any
	
	if (t) {
		qobuz_keys = t.data
	} else {
		console.log(`qobuz: no keys found, creating new ones`)

		qobuz_keys = await get_app_id_and_secrets()
		db.insert(schema.thirdparty_store)
			.values({ kind: 'qobuz_keys', data: qobuz_keys })
			.run()
	}

	console.log(`qobuz: created api instance with client credentials`)
}
